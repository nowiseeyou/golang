# 内建容器 #

## 数组 ##

- [10]int 和 [20]int 是不同类型。
- 调用func f(arr [10]int)会拷贝数组
- 在golang中一般不直接使用数组


## 切片（slice） ##

- slice 本身没有数据，是对底层array的一个 view
- arr的值变为[0 1 10 3 4 5 6]

    
     	arr := [...] int {0,1,2,3,4,5,6}
	 	s1 := arr[2:6]
	 	s2 := arr[3:5]



- s1的值为[2,3,4,5]，s2的值为[5,6]
- slice 可以向后扩展，不可以向前扩展
- s[i] 不可以超越len(s)，向后扩展不可以超越底层数组cap(s)
- slice : ptr(开始指针)、len(当前切片长度)、cap(切片开始到arr最后值的长)	


    	s3 := append(s2,10)
		s4 := append(s3,11)
		s5 := append(s4,12)

		fmt.Println("s3,s4,s5=",s3,s4,s5)
		fmt.Println("arr =",arr)


- 添加元素时如果超越cap,系统会重新分配更大的底层数组
- 由于值传递的关系，必须接收append 的返回值
-  s = append(s,val)
		



		func printSlice(s int[]){
			fmt.Println("%v，len= %d，cap=%d\n",s,len(s),cap(s))
		}
    	func main(){
			fmt.Println("Creating Slince")
			var s []int //zero value for slice is nil
			
			for i := 0; i < 100; i++ {
				s = append(s,2 * i + 1)
			}

			s1 := []int{2,4,6,8}
			printSlice(s1)

			s2 := make([]int,16)

			s3 := make([]int,10,32)

			printSlice(s2)
			printSlice(s3)

			fmt.Println("Copying Slice")
			copy(s2,s1)
			printSlice(s2)

			fmt.Println("Deleting elements from slice")
			s2 = apend(s2[:3],s2[4:]...)
			printSlice(s2)

			fmt.Println("Poping from front")
			front := s2[0]
			s2 = s2[1:]
			
			fmt.Println("Poping from back")
			tail := s2[len(s2) - 1]
			s2 = s2[:len(s2) - 1]

			fmt.Println(front,tail)
			printSlice(s2)
		}

